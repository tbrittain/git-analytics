# CLAUDE.md

## Project Overview

Git Analytics is a desktop application that provides insights and visualizations for Git repositories. It allows users to analyze commit history, contributor activity, and code changes through an intuitive interface.

## Architecture

- **Framework:** Wails v2 (Go backend + Vue 3/TypeScript frontend)
  - **Backend:** Go 1.25 (`main.go`, `app.go`)
- **Frontend:** Vue 3, TypeScript, Vite (`frontend/src/`)
- **Build:** Windows + macOS support via Wails

Primary dependencies for core functionality:
- `go-git` for Git repository analysis (`github.com/go-git/go-git/v6`)
- `modernc.org/sqlite` for data layer (pure Go, no CGO)
- `wailsjs` for frontend-backend communication (auto-generated by Wails)

Not focusing much on the UI for now until we have a solid backend foundation

## Development

```sh
wails dev      # Run in dev mode with hot reload
wails build    # Build for current platform
```

Frontend dependencies:
```sh
cd frontend && npm install
```

## Project Structure

```
app.go                  # Go backend logic (bound to frontend via Wails)
main.go                 # Wails app entry point, window config
frontend/src/
  App.vue               # Root Vue component
  components/           # Vue components
  assets/               # Fonts, images
frontend/wailsjs/       # Auto-generated Wails JS bindings
build/                  # Platform-specific build assets
```

## Design Goals

1. We will proceed with core functionality (nearly all backend) before implementing the UI.
2. Code should be simple and designed for testability. Add tests for critical logic, especially around Git repository analysis and data handling. Use Go's built-in testing framework and aim for good coverage on core functions.
3. Modular design - core logic should be standalone and not often to change if we want to swap out anything at the "boundary" (e.g. Git library, database, frontend framework). To this point, use interfaces and dependency injection where appropriate to decouple components (manual DI, no frameworks). For example, we can define a `GitRepository` interface that abstracts away the underlying Git library, allowing us to swap out `go-git` for another implementation in the future without affecting the rest of the codebase.

## General features of the app

- A read-only interface of a given Git repository. The Git repository should already exist on disk, and the user should be able to select it via a file dialog. Upon load, there should be a background indexing processes (details TBD) that will create a new SQLite database file in the same directory as the Git repository (automatically added to git/info/exclude so that it is never committed). This database will be used to power all analytics and visualizations in the app, and will be updated incrementally as new commits are added to the repository.
- The primary features will be related to the following:
  - Commit graph visualization (total and by contributor)
  - Code change heatmaps (e.g. by time of day, day of week, etc.)
  - Contributor activity timelines
  - File change history and statistics (including churn, most changed files, etc.) in a hierarchical format (to understand changes at the directory level as well as file level)